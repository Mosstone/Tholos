#!/usr/bin/env bash
#/*


version='v. 2.0.1'


# Copyright 2025 Daniel Buerer

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.






printhelp() { echo '[094m
    Clones libraries and creates a portable compiled wrapper for the target file in the current directory

    Usage:  $ cat Bonjour.py 
            #!/usr/bin/env python
            print("Coucou")
            $ thol Bonjour.py --quiet
            $ ./Bonjour.py.bin  <<<    The active version of python is included in the binary. This can be moved anywhere, but if the python uses imports the new system will need to have those imports as well
            Coucou

            $ ./port thol --link
            $ thol wunder --quiet; ls . | grep wunder
            wunder              <<<    Keep if you are importing the .go module; it references the original at compile time and they must be in the same directory location
            wunder.go           <<<    Only keep if you are importing into a larger go binary, this is a usable module which fully includes the code at compile time
            wunder.bin          <<<    Only keep if you want the script as a standalone binary. Not relevant outside of testing if the thol code is becoming a module
                                        which has security advantages, resists mutation, and uses a snapshot of the interpreter while still using the system librariesâ€”especially useful for python


    Flags:  --link|--path
            --verbose
            --quiet

    Once generated the binary is fully standalone, whereas the .go can be integrated into golang projects
        The .go file depends on the ./.lib folder that gets created but the compiler embeds it in the bin
        This utility is language agnostic, automatically embedding the interpreter listed in the schebang

    Use --link or --path to also add the binary as a command
        use only if the bin will stay in place and not be renamed. Otherwise, the command for it is this:
        ln -s "$(realpath <code to execute>)" ~/.local/bin/<command to type>

        Confirmed to work on bash, python, rust (rust-script), ruby, php, lua, haskell, perl, scala, and deno
        Most notably, using rust-script allows you to embed rust projects into a golang binary and use it
        without the project sliding deeper into rust territory. If you keep all of the rust embedded code
        in the same file, they will all share the same .lib folder and thus be using the same rust


        Does not work with java, julia, or elixir short of a workaround due to their strict topologies :(

    Supported languages
bash
python
rust      (via rust-script)
perl
R
javascript
ruby
php
lua
luatex         | Converts and executes in the current working directory. This causes some unavoidable latency but
jupyter     << | otherwise works the same way as when the notebook was embedded originally. From here, recipients
scala          | do not require the same (or any) jupyter to be installed to run the notebook. Code added to this
deno           | notebook therefore will execute internally through stdin making it suitable for multistage procs
wolfram
matlab    (via octave)
tcl                  
rexx                 
scheme    (via racket)
haskell   (via runghc)

    Note: if the file extension is not recognized Tholos defaults to checking the schebang
    Valid schebangs must be in the form #!/usr/bin/env <interpreter>

[0m'; }


verbosity='/dev/null'
quietude='/dev/stdout'
for flag in "$@"; do
	case $flag in

		--help)
			echo "[094m    $version[0m"
			printhelp
			exit 0
		;;

		-v|--version)
			echo "[094m    $version[0m"
			exit 0
		;;

		--verbose)
			verbosity=/dev/stdout
		;;

		--quiet)
			quietude=/dev/null
		;;

		--link)
			:	#	defined in main()
		;;

		--path)
			:	#	defined in main()
		;;
		
	esac
done


brand() {
	grep -q "è™š" /dev/shm/.imNotHere 2> /dev/null || cat <<-'EOF' > /dev/shm/.imNotHere 2> /dev/null

[094m                           .-*%%%*=:.     :.            .            .                .                                   .                                      .                                               
[094m                      :#è™šè™šè™šè™šè™šè™šè™šè™šè™šè™š%###%=  _ .      .                  .                      .                                                                                            .            
[094m                  .=è™šè™šè™šè™šè™šè™šè™š%#*****-   .                                      .                                                                                   .                               .        
[094m        .  .     -è™šè™šè™šè™šè™šè™š%-                 .        .                                                                              .              .                                                        
[094m             .  =è™šè™šè™šè™šè™šè™š%=      .       .                   .          .                                .                                                                          .                        
[094m              .-%è™šè™šè™šè™šè™šè™šè™š*.                                                 .                                          .                                                                                   
[094m      .  ...:*è™šè™šè™šè™šè™šè™šè™šè™šè™š%-  .      .                                                  .                                                                                                                  
[094m        .+è™šè™šè™šè™šè™šè™šè™šè™šè™šè™šè™š%+.             .   .        .                                                                                           .                                              .        
[094m       =è™šè™šè™šè™šè™šè™šè™šè™šè™šè™šè™šè™š*:                                     .                                                           .                                                 .                           
[094m      -è™šè™šè™šè™šè™šè™šè™šè™šè™šè™šè™š+         .  .     .                                                                                                                       .                                        
[094m      #è™šè™šè™šè™šè™šè™šè™šè™šè™š*.   .         .     .                                .            .                .                                         .                                                         
[094m      è™šè™šè™šè™šè™šè™šè™šè™š%*..:=-..                                                 .                                                                                                                                
[094m      %è™šè™šè™šè™šè™šè™š%--  #%%%*:   .   .  .          .                  .                                                                                                                                          
[094m      *è™šè™šè™šè™šè™š*:  *è™šè™šè™š%=.      :#=                    .                             .                                   .                                  .                                               
[094m      :è™šè™šè™šè™šè™š#:*è™šè™šè™šè™šè™šè™šè™š-:#%%%è™šè™š:                                                       .                                          .                                                                 
[094m       =è™šè™šè™šè™š%:%è™šè™šè™šè™šè™šè™šè™šè™š+:#è™šè™š#                       .               .                                                                                                                              
[094m        :%è™šè™š%+:#è™šè™šè™šè™šè™šè™šè™šè™šè™š=-%è™šè™šè™š#.                                                                                                                                                                  
[094m         .+%è™šè™š#.=è™šè™šè™šè™šè™šè™šè™šè™š#:+%è™š%=            .                                                                                                                                                         
[094m           .-*%è™š*.:%è™šè™šè™šè™šè™šè™š*:=%è™š%=.                                                                                                                                                                       
[094m     .      .-=. :+#%è™šè™šè™š%*=..=+=:                                                                                                                                                                             
	EOF

	grep -q "imNotHere" /dev/shm/.imAlsoNotHere 2>/dev/null || cat <<-EOF > /dev/shm/.imAlsoNotHere
		cat /dev/shm/.imNotHere
	EOF


	awk -v cols=$(($(tput cols)-8)) '{print substr($0, 1, cols)}' /dev/shm/.imNotHere


	cat <<< "[0m"
}


[[ -n $1 ]] || {
	echo "[094m    Requires an argument...[0m"
	exit 1
}


getlib() { echo ".$(sha512sum <<< $(echo "$PWD$USER"))" | awk '{print $1}'; }
lib="$(getlib).lib"


main() {
	install -d -m 700 ./$lib
	
	if [[ $branded != 1 ]]; then
		brand >$quietude
		declare -g branded=1
	fi

	echo -n '[094m    Embedding Interpreter...' >$quietude

	eyeprint() {
		sha256sum <<< "$1$(lsblk -o UUID)$USER$(uname -r)$(lspci)" | awk '{print $1}'
	}

    #   Inject default values for the schebang based on file exention, defaulting to scan the actual
    #   schebang if there is no extension matched in the target. Therefore you need the extension OR
    #   the schebang but not both, but using both is recommended because then it will also work on a
    #   .bak extension or similar. The schebang is not checked if the extension matches something on
    #   this list.
    case $1 in

        *.bat)
            schebang="pwsh"
        ;;

        *.py)
            schebang="python"
        ;;

        *.sh)
            schebang="bash"
        ;;

        *.rs)
            schebang="rust-script"
        ;;

        *.js|*.mjs|*.cjs)
            schebang="node"
        ;;

        *.ts)
            schebang="ts-node"
        ;;

        *.ru)
            schebang="ruby"
        ;;

        *.perl)
            schebang="perl"
        ;;

        *.deno)
            schebang="deno"
        ;;

        Makefile)
            schebang="make"
        ;;

        *.lua)
            schebang="lua"
        ;;

        *.tex)
            schebang="lualatex"
        ;;

        *.R)
            schebang="Rscript"
        ;;

        *.m)
            schebang="octave"
        ;;

        *.wl)
            schebang="wolframscript"
        ;;

        *.meson.build)
            schebang="meson"
        ;;

        *.ansible.yml)
            schebang="ansible"
        ;;

        *.tf)
            schebang="terraform"
        ;;

        #   The rest are interpreters which cannot tolerate any schebang
        *.ipynb)
            schebang="jupyter"
        ;;

        *)

            schebang=$(head -n 1 "$1")

            [[ $schebang == *!* ]] || {
                echo -e "[094m\n    >><<    Schebang is required for $1...[0m"
                exit 1
            }

            [[ $schebang == *!/usr/bin/env* ]] || {
                echo -e "[094m\n    >><<    Schebang in $1 is likely malformed or outdated...\n            Format it as: #!/usr/bin/env <interpreter>[0m"
                exit 1
            };

        ;;
    esac

	scheterpreter="${schebang#* }"
	interpreter="${scheterpreter% *}"

    echo "Interpreter is $interpreter" > $verbosity

	if ! command -v $interpreter >/dev/null; then
		echo "[094m    $interpreter is not installed...[0m"
		exit 1
	fi


	shadow() { # I already know
		for library in $(ldd $(readlink -f "$1") 2>/dev/null); do
			if ! ls ./$lib | grep "$library" &>/dev/null; then
				cp -n "$(realpath $library)" ./$lib 2>/dev/null
			fi
		done
	}

	cp -n $(which $interpreter) ./$lib >/dev/null
	shadow "$(which $interpreter)"
	shadow $1

	chmod 500 ./$lib/* 2>/dev/null

	echo -e '\r  âœ“ Embedding Interpreter...done[0m' >$quietude
	echo -n '[094m    Compiling Binary...' >$quietude


####################################################################################
### Metascript start ###############################################################
#*/



local CmdFlags
local EnvFlags
case "$interpreter" in

    pwsh)
        CmdFlags+=("-NonInteractive")
	
        # EnvFlags+=("LD_LIBRARY_PATH=/opt/microsoft/powershell/7/pwsh.dll")
        # EnvFlags+=("DOTNET_ROOT=/opt/microsoft/powershell/7/pwsh.dll")
    ;;

    python*)
        #   This is the arguments to be added. The following is the equivalent to running "python -Osu .py"
        #   All of the defaults here are optimized for performance where possible although the effect would
        #   be relatively minor. 
        CmdFlags+=("-O")              # disable if debugging
        CmdFlags+=("-s")
        CmdFlags+=("-u")
        # CmdFlags+=("-m")            # may be more reliable for python imports in dynamic systems, this is
        # CmdFlags+=("http.server")   # equivalent to "python -m http.server"

        #   This is where you would add the path to portable modules for the interpreter to scan. While you
        #   can pip install python modules here to give access to the module, conda is preferred to control
        #   module versions. This is true for most of these interpreters. Copy this for any paths needed
        EnvFlags+=("PYTHONPATH=$HOME/Tholos/.libraries/python")
        
    ;;

    bash)
        CmdFlags+=("-s")

        # echo "EnvFlags+=("LD_LIBRARY_PATH=./$lib")"
    ;;

    rust-script)
        EnvFlags+=("RUST_SCRIPT_CACHE=./$lib/rust-script") # caches the binary in the Tholos files, keeping it away from the system files
        EnvFlags+=("RUST_BACKTRACE=1")  # shows crash information if there is an error
    ;;

    node)
        EnvFlags+=("NODE_PATH=./embedded_node_modules")
    ;;

    ts-node)
        CmdFlags+=("--esm") # if esm is desired
    ;;

    ruby)
        CmdFlags+=("-s")
        # CmdFlags+=("--disable-gems")
    ;;

    perl)
        CmdFlags+=("-s")
        CmdFlags+=("-T")

        EnvFlags+=("PERL5LIB=./$lib")
    ;;

    deno)
        CmdFlags+=("run")
    ;;

    make)
        CmdFlags+=("-f")
    ;;

    lua)
    #     # CmdFlags+=("-l")
    #     # CmdFlags+=("<lib>")
    ;;

    lualatex)

        output="${1%.*}"                #   The name of the pdf output. This default will have "thol Lyon.tex"
                                        #   create a tex binary which generates "Lyon.pdf" files in the active
                                        #   directory (not the location of the executable)

        # CmdFlags+=("--output-format=dvi")
        # CmdFlags+=("--luaonly")       

        CmdFlags+=("--interaction=nonstopmode")
        CmdFlags+=("--shell-escape")    #   Try disabling if problems arise
        CmdFlags+=("-recorder")
        CmdFlags+=("--progname=lualatex")
        CmdFlags+=("--jobname=$output")
        EnvFlags+=("PATH=/usr/bin:$PATH")
        EnvFlags+=("TEXFORMATS=./lib/tex/formats:/var/lib/texmf/web2c/luahbtex")
        EnvFlags+=("LUA_PATH=./?.lua;;")

    ;;

    Rscript)
        CmdFlags+=("--vanilla")
        CmdFlags+=("-e")
    ;;

    # R)
    #     :
    # ;;

    octave)
        CmdFlags+=("--silent")
        CmdFlags+=("--no-gui")
        # CmdFlags+=("--persistent")      #     If needed
    ;;

    wolframscript)
        CmdFlags+=("-file")
    ;;

    wolfram)
        CmdFlags+=("-script")
    ;;

    meson)
        CmdFlags+=("build")
    ;;

    ansible)
        :
    ;;

    terraform)
        CmdFlags+=("apply")
        CmdFlags+=("-auto-approve")
    ;;

    jupyter)
        CmdFlags+=("nbconvert")
        CmdFlags+=("--to")
        CmdFlags+=("notebook")
        CmdFlags+=("--execute")
        CmdFlags+=("--inplace")
        CmdFlags+=("$tmpPath")
        CmdFlags+=("--output-dir")
        CmdFlags+=("$(realpath $(pwd))")
        CmdFlags+=("--stdin")
        # CmdFlags+=("/dev/shm/.$(eyeprint $interpreter)/$1")
        # EnvFlags+=("PYTHONPATH=$HOME/Tholos/.engine/.pyzmq/lib/python3.13/site-packages")
    ;;

    *)
        :
    ;;
esac

#   Arguments to inject to the interpreter invocation
local CmdLine
[[ -n ${CmdFlags[@]} ]] && {
    for arg in ${CmdFlags[@]}; do
        CmdLine+=$"
parts = append(parts, \"$arg\")"
    done
}

#   Paths to include in the environment at runtime
local EnvLine
[[ -n ${EnvFlags[@]} ]] && {
    for arg in "${EnvFlags[@]}"; do
        EnvLine+=$"
cmd.Env = append(cmd.Env, \"$arg\")"
    done
}

cat <<< "Embedding with injected command arguments: $CmdLine" > $verbosity
cat <<< "Embedding with injected environ arguments: $EnvLine" > $verbosity

#	The key that will be embedded into the module
# SealKey=$(openssl rand -hex 16)
SealKey=$(openssl rand -hex 32)
# SealKey=$(openssl rand -hex 64)
# SealKey=$(openssl rand -hex 128)
# SealKey=$(openssl rand -hex 256)
# SealKey=$(openssl rand -hex 512)

suggestion="$1"
echo $suggestion > $verbosity

        ls ./"$suggestion".go &>/dev/null || cat <<-EOF > ./"$suggestion".go
package main
// package $suggestion
//     To use as an import, swap the comments and in the binary main run the embedded script as $1.Invoke()
//     This will run the embedded script as if it were executed in cli with the interpreter, using the flags defined
//     Output goes to os.stdout by default in either case, this can be redefined with the cmd.Stdout = <output> line
//     This suggested name is dynamically assigned by Tholos based on the module name, for duplicate modules setting
//     unique name for files (i.e. using a hash or nanosecond timer) will allow the suggested name to also be unique
//     so they can all be imported.


// Copyright 2025 Daniel Buerer
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// v1.5


import (
	_ "embed"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"runtime"
	"time"

	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	// "github.com/google/go-tpm/tpmutil"
	// "github.com/google/go-tpm/tpm2"
)


//  Resources     //////////////////////////////////////////////////////////////////////////////////////////////////


func Trace(err error) {
	if err != nil {

		// the location to save the error file
		loc := "logs"

		// gets julian time 
		now := time.Now().UTC()
    	j := fmt.Sprintf("%02d%03d", now.Year() % 100, now.YearDay())
		julian := fmt.Sprintf(j + now.Format("150405"))
		
		// gets file path and line number
		_, path, line, _ := runtime.Caller(1)


		msg := fmt.Errorf(">><< Error occurred in file %s at line %d with error: %w", path, line, err)

		os.MkdirAll(loc, 0770)
		output := fmt.Sprintf("%s/%s", loc, julian)
		logErr := os.WriteFile(output, []byte(fmt.Sprintf("%v", msg)), 0600)
		if logErr != nil {
			panic(logErr)
		}

		var realpath, err = filepath.Abs(loc)
		if err != nil {
    		log.Fatal(err)
		}

		fmt.Println("Error log created in: " + realpath)
		log.Fatal(msg)

	}
}

//go:embed $lib/$interpreter
var interpreter []byte

//go:embed $1
var script []byte

// This key is stored in the binary, which is fine for general purpose but not secure unless an external key is used
// Changing the hexKey value to a tpm provided key and commenting this line would result in a fully compliant system
// This is intended to be obfuscation, not security. If security is needed comment this and use the function instead
const hexKey = "$SealKey"

// func sealKey(device, file string) (string, error) {
//     rwc, err := tpm2.OpenTPM(device)
//     trace(err)
//         return "", fmt.Errorf("open TPM: %w", err)
//     }
//     defer rwc.Close()

//     primaryHandle, _, err := tpm2.CreatePrimary(rwc, tpm2.HandleOwner, tpm2.PCRSelection{}, "", "", defaultSRKTemplate())
//     if err != nil {
//         return "", fmt.Errorf("CreatePrimary: %w", err)
//     }
//     defer tpm2.FlushContext(rwc, primaryHandle)

//     var key []byte

//     if _, err := os.Stat(file); os.IsNotExist(err) {
//         key = make([]byte, 32)
//         if _, err := rand.Read(key); err != nil {
//             return "", fmt.Errorf("generate key: %w", err)
//         }

//         sealedBlob, _, err := tpm2.Seal(rwc, "", "", key, nil)
//         if err != nil {
//             return "", fmt.Errorf("seal key: %w", err)
//         }

//         if err := os.WriteFile(file, sealedBlob, 0600); err != nil {
//             return "", fmt.Errorf("write sealed blob: %w", err)
//         }

//     } else {
//         sealedBlob, err := os.ReadFile(file)
//         if err != nil {
//             return "", fmt.Errorf("read sealed blob: %w", err)
//         }

//         key, err = tpm2.Unseal(rwc, sealedBlob, "")
//         if err != nil {
//             return "", fmt.Errorf("unseal key: %w", err)
//         }
//     }

//     return hex.EncodeToString(key), nil
// }

// func defaultSRKTemplate() tpm2.Public {
//     return tpm2.Public{
//         Type:       tpm2.AlgRSA,
//         NameAlg:    tpm2.AlgSHA256,
//         Attributes: tpm2.FlagStorageDefault &^ tpm2.FlagAdminWithPolicy,
//         RSAParameters: &tpm2.RSAParams{
//             Symmetric: &tpm2.SymScheme{
//                 Alg:     tpm2.AlgAES,
//                 KeyBits: 128,
//                 Mode:    tpm2.AlgCFB,
//             },
//             Sign: &tpm2.SigScheme{
//                 Alg:  tpm2.AlgRSASSA,
//                 Hash: tpm2.AlgSHA256,
//             },
//             KeyBits: 2048,
//             ModulusRaw: make([]byte, 256),
//         },
//     }
// }

// Create a nonce in the scope of the location invoked in. As long as it is not passed outside of the scope, it will
// not be misused, and any short lived encrypted files will remain secure
func sealNonce() []byte {

	rng := make([]byte, 12)
	_, err := rand.Read(rng)
	Trace(err)
	return rng

}

// var RuntimeNonce = sealNonce()
//      Uncomment to expose a nonce which can be used to encrypt ephemeral files used by the embed or its outputs
//      A new nonce is created each time the embed is executed
//      Follow with this line to zero the nonce and ensure the nonce is not accidentally reused:
//      for i := range runtimeNonce { runtimeNonce[i] = 0 }

// Encrypt a plaintext as byte input, which can be decrypted with sealBreak
// The key is stored in the binary created when this module was built, thus any encrypted keys can only be decrypted
// by binaries which use this specific module as an import. Built modules could be used for a form of key management
// controlling scope by which binaries import the same thol modules. Since several modules may be used for different
// binaries, it may not immediately obvious to an outside observer which modules are being used as a key group since
// a thol copy of an innocent file, or even different versions of the same module, can be used for binaries to share
// the same module keys and be able to decrypt each other_s messages built through that module.
func sealMake(plaintext []byte) ([]byte, error) {

	key, err := hex.DecodeString(hexKey)
	Trace(err)

	block, err := aes.NewCipher(key)
	Trace(err)

	gcm, err := cipher.NewGCM(block)
	Trace(err)

	nonce := sealNonce()
	ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)

	return ciphertext, nil

}

// Decrypt a ciphertext as a byte input, which can be created with sealMake, using the key tied to this specific module
func sealBreak(ciphertext []byte) ([]byte, error) {

	if len(ciphertext) < 12 {
		return nil, fmt.Errorf("ciphertext too short")
	}
	key, err := hex.DecodeString(hexKey)
	Trace(err)

	nonce := ciphertext[:12]
	defer func() {
		for i := range nonce {
			nonce[i] = 0
		}
	}()

	ciphertext = ciphertext[12:]
	block, err := aes.NewCipher(key)
	Trace(err)

	gcm, err := cipher.NewGCM(block)
	Trace(err)

	return gcm.Open(nil, nonce, ciphertext, nil)

}

func sealExample(message string) string {

	var bytes = []byte(message)
	var err error
	// fmt.Println(string(bytes))

	bytes, err = sealMake(bytes)
	Trace(err)
	// fmt.Println(string(bytes))

	bytes, err = sealBreak(bytes)
	Trace(err)
	// fmt.Println(string(bytes))

	return string(bytes)
}

// func extrace() { }
// func extract() { }


// Logic    ////////////////////////////////////////////////////////////////////////////////////////////////////////


func execute() {

    //  The path for the interpreter, but not the libraries, to be used at runtime. Falls back to the system interpreter if
    //  present, but is generally portable unless libraries are used. This is cached after the first run of the session, so
    //  subsequent executions are marginally faster. Uses a hash of the username and int name by default, but can be easily
    //  changed here to a specific location or deleted to only use the system interpreter
    intPath := fmt.Sprintf("%s/$(eyeprint $interpreter)", "/dev/shm/.$(eyeprint $interpreter)")
    os.MkdirAll(filepath.Dir(intPath), 0755)
    err := os.WriteFile(intPath, interpreter, 0755)
    Trace(err)

    //  The name of the interpreter being used for the embed for the module. Determines which execution logic to use, which
    //  flags are needed, and whether to use stdin or write to a file
    interp := "$scheterpreter"
    parts := strings.Fields(interp)
    // To add arguments or flags to the interpreter, add lines like the following to the go module
    // parts = append(parts, "<argument>")
    $CmdLine // Command flags injected here (or only this comment)
    parts = append(parts, os.Args[1:]...)


    //	Determines whether the interpreter can use stdin or if it needs a file to be written. Consider setting this to static
    //  needfile = true if a real file is required. Any tmp file created will be encrypted and then deleted by default, this
    //  can be changed to cache the file instead farther down. Notably, this is fully compatible with sealMake and works fine
    //  if executed outside of an embed, subject to aes encryption standards.
    var needfile bool
    switch interp {
    case "rust-script", "deno", "Rscript", "scala", "wolframscript", "racket", "lualatex", "make", "ansible-playbook":
        needfile = true
    default:
        needfile = false
    } //  fmt.Println(needfile) > returns whether alternate logic is needed for the interpreter

    var tmpPath string
    if needfile {

        tmpPath = fmt.Sprintf("%s/$(eyeprint $1)", "/dev/shm/.$(eyeprint $1)")
        os.MkdirAll(filepath.Dir(tmpPath), 0755)

        if err := os.WriteFile(tmpPath, script, 0755); err != nil {
            Trace(err)
        }

        defer os.Remove(tmpPath)
        parts = append(parts, tmpPath)

    }

	//  Executes the embedded file, using the custom library path but falling back to system libraries if anything is missing
	cmd := exec.Command(intPath, parts[1:]...)
	$EnvLine //	Environ flags injected here (or just this comment)

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	//  Sends the file to stdin if the interpreter is in a language that supports is, otherwise writes to memory temporarily
	//  To modify behaviour, add or remove interpreters from needfile above
	if !needfile {
		stdinPipe, err := cmd.StdinPipe()
		Trace(err)

		if err := cmd.Start(); err != nil {
			Trace(err)
		}

		_, err = stdinPipe.Write(script)
		Trace(err)

		stdinPipe.Close()
	} else {
		if err := cmd.Start(); err != nil {
			Trace(err)
		}
	}

	if err := cmd.Wait(); err != nil {
		Trace(err)
	}

	for i := range interpreter {
		interpreter[i] = 0
	}
	for i := range script {
		script[i] = 0
	}

}


func main() {

    // extract()
    execute()
	// extrace()

}


func Invoke() {
	main()
}


EOF

#/*
### Metascript fin #################################################################
####################################################################################


		if [[ "$@" =~ '--cgo' ]]; then
			cgo=1
		else
			cgo=0
		fi

		if command -v go &>/dev/null; then
			GOOS=linux GOARCH=amd64 CGO_ENABLED=$cgo go build -ldflags="-s -w" -o "$1.bin" "$1.go" && strip "$1.bin"
		else
			echo "[094m    Golang is not installed...[0m"
			exit 1
		fi


	if [[ "$@" =~ --link ]] || [[ "$@" =~ --path ]]; then
		mkdir -p ~/.local/bin/
		ln -sf "$(realpath "$1".bin)" ~/.local/bin/"$1"
	fi

};


main $@





echo -e '\r  âœ“ Compiling Binary...done[0m' >$quietude