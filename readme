    Clones libraries and creates a portable compiled wrapper for the target file in the current directory

    Usage:  $ port port-src.sh
            $ ./myscript.sh.bin <<< Fully portable, libraries and interpreter is included in binary
            Bonjour Monde
            $ ls . | grep myscript
            port-src.sh
            port-src.sh.go      <<< You can delete this
            port-src.sh.bin

            $ port "Bonjour" --link
            $ Bonjour
            Bonsoir
            $ Bonjour
            Bonsoir

    Once generated the binary is fully standalone, whereas the .go can be integrated into golang projects
        The .go file depends on the ./.lib folder that gets created but the compiler embeds it in the bin
        This utility is language agnostic, automatically embedding the interpreter listed in the schebang


    Use --link or --path to also add the binary as a command
        use only if the bin will stay in place and not be renamed. Otherwise, the command for it is this:
        ln -s "$(realpath <code to execute>)" ~/.local/bin/<command to type>


    There are two outputs: the compiled .bin executable which is compiled as a fully embedded binary, and
        the editable .go which the .bin is compiled from. All of the embedded files the go uses is in the
        .lib folder which is shared for all compiled go outputs in the same directory. So if they are all
        in the same folder and then included in the same golang compile, the embed would only include one
        version of the interpreter for all of them. The resulting large binary may then be able to access
        the embedded files and their interpreters. This was measured to have much faster access times than
        accessing external files from the compiled golang, 0.5198ns/op / 8552ns/op so about 16452x faster


    Requires a valid schebang in this format: #!/usr/bin/env <interpreter>
        Port begins matching after the ! so you can use other comments such as // or % if there is ever a
        requirement. Anything other than that i.e. /usr/bin/bash will not pass the enforcement check.


    Confirmed to work on bash, python, rust (rust-script), ruby, php, lua, haskell, perl, scala, and deno
        Most notably, using rust-script allows you to embed rust projects into a golang binary and use it
        without the project sliding deeper into rust territory. If you keep all of the rust embedded code
        in the same file, they will all share the same .lib folder and thus be using the same rust


    Does not work with java, julia, or elixir currently due to their strict topologies :(


    Note that while the interpreter is embedded and included in the .bin, the modules are loaded from the 
        original environment. This works well with anaconda and miniforge. I expected that the binary will
        need to be regenerated anyway due to security patches, so at least this way it means only updating
        the interpreter every few decades rather than regenerating all 1354356 port files every month then
        figuring out which one exploded

    If you really need static module versions, you could use an anaconda/miniforge environment (which the
        binaries will then use). Generated binaries will use the module paths of the active environment
        The system version of the interpreter at that point can change without affecting the port files


    Embedded files are written to /dev/shm/ and obfuscated using a hash of the name+user. Therefore there
        is no possibility of collisions from different users, and the paths are not obvious to a listener
        The temporary files are deleted after execution, also preventing collisions if different versions
        of the same file is run, and the 
        

    Supported languages
bash
python
rust-script
perl
R
javascript
ruby
php
lua
haskell
scala
deno
matlab (I think? it works with octave)
wolfram

    Unsupported languages
java
fortran
assembly
elixir
zig

TODO
    encrypt temporary files
    compile time rng tag to further reduce collisions
    move out of /dev/shm/ due to rising property values


If this code is used in a publication or in a system which is used in a publication, please cite the following:
    **Buerer, Daniel** (2025). *port* (Version 1.1) [Computer software].
    https://doi.org/10.5281/zenodo.15350673
or reference the citation.cff for standard format information
